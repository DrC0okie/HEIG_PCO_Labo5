%! suppress = MissingLabel
\documentclass{article}
\usepackage[T1]{fontenc}
\usepackage[main=english]{babel}
\usepackage{url}
\usepackage{lastpage}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage[a4paper, margin=2cm, footskip=18.3pt]{geometry}
\usepackage{listings}
\usepackage[usenames]{color}

\newcommand{\header} {
    \setlength{\headheight}{30pt}\pagestyle{fancy}
    \fancyhead[L]{\includegraphics[height=20pt]{~/Templates/heig-logo}}\fancyhead[C]{PCO 2023\\ Lab 5}
    \fancyhead[R]{Timothée Van Hove \& Aubry Mangold\\\today}\fancyfoot[C]{}
    \fancyfoot[R]{Page \thepage~sur \pageref{LastPage}}\renewcommand{\footrulewidth}{0.3pt}
}


\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
    language=C++,
    aboveskip=3mm,
    belowskip=3mm,
    showstringspaces=false,
    columns=flexible,
    basicstyle={\small\ttfamily},
    numbers=left,
    numberstyle=\tiny\color{mygray},
    keywordstyle=\color{blue},
    commentstyle=\color{mygreen},
    stringstyle=\color{mymauve},
    breaklines=true,
    breakatwhitespace=true,
    tabsize=4
}

\begin{document}
    \header


    \section{Introduction}


    \section{Analysis}
    Multiple threads—representing clients and a barber—operate independently but require careful synchronization to ensure correct behavior. The core challenge lies in managing the interactions between these threads, which include clients entering and exiting the salon, waiting for their turn, and the barber providing services and managing idle time. The barber and clients are modeled as separate threads, each executing its own logic. The salon operates with limited capacity, necessitating a mechanism to control client access and service order.

    The Mesa monitor concept must be used to synchronize the barber and client threads. It involves condition variables and a mutex, offering a structured approach to manage shared resources and thread coordination. Several condition variables are used to signal different states such as the availability of the barber, a client waiting for a haircut, the completion of a haircut. A mutex lock must be utilized to protect shared variables and ensure atomicity in operations. Threads acquire the lock before checking or modifying shared states and release it during waiting to avoid deadlock scenarios.

    Incorporating animations to reflect real-time actions add a layer of complexity to the synchronization scheme. Animations in the simulation are blocking, meaning the executing thread is held up until the animation completes. Because, the mutex is systematically unlocked before the animation and re-locked after, this disrupt the synchronization flow, as the order of the execution is different before and after the animation.

    \pagebreak

    \section{Conception}

    \subsection{Barber Cycle}

    The Barber class encapsulates the behavior of the barber in the simulation. The barber's primary responsibilities are to provide services to clients and manage idle time. The operational cycle is as follows:

    \begin{lstlisting}[caption={The barber operational cycle}, captionpos=b, label=lst:1]

    void Barber::run() {
        while (_salon->isInService() || _salon->getNbClient() > 0){
            _interface->consoleAppendTextBarber("Je suis prêt à accueillir un client");
            if (_salon->getNbClient() == 0) {
                _interface->consoleAppendTextBarber("Pas de client, je vais dormir");
                _salon->goToSleep();
                continue;
            }else{
                _interface->consoleAppendTextBarber("J'appelle le client suivant");
                _salon->pickNextClient();
            }

            _interface->consoleAppendTextBarber("J'attends que le client vienne sur la chaise");
            _salon->waitClientAtChair();
            _interface->consoleAppendTextBarber("Je vais coiffer le client");
            _salon->beautifyClient();
        }
        _interface->consoleAppendTextBarber("La journée est terminée, à demain !");
    }

    \end{lstlisting}

    \begin{itemize}
    \item \textbf{Checking for Clients}: The barber continuously checks if clients are present in the salon. This check determines the barber's subsequent actions.
    \item \textbf{Sleeping when Idle}: If no clients are present, the barber goes to sleep. The \texttt{goToSleep()} method involves waiting on a condition variable until a client arrives and wakes the barber up.
    \item \textbf{Serving Clients}: When clients are present, the barber calls \texttt{pickNextClient()} to select the next client for service. The barber then waits for the client to be ready on the working chair (\texttt{waitClientAtChair()}) before proceeding with the haircut (\texttt{beautifyClient()}).
    \end{itemize}

    This cycle repeats until the salon is no longer in service, at which point the barber concludes the workday.

    \pagebreak

    \subsection{Clients Cycle}

    The Client class represents the behavior of clients visiting the salon. Clients attempt to access the salon and receive haircuts :

    \begin{lstlisting}[caption={The clients operational cycle}, captionpos=b, label=lst:2]

    void Client::run() {
        while (_salon->isInService()) {
            _interface->consoleAppendTextClient(_clientId, "Je regarde s'il y a de la place dans le salon");
            if (!_salon->accessSalon(_clientId)) {
                _interface->consoleAppendTextClient(_clientId, "Le salon est plein, je reviens plus tard");
                _salon->walkAround(_clientId);
                continue;
            }
            _interface->consoleAppendTextClient(_clientId, "Je vais sur la chaise du barbier");
            _salon->goForHairCut(_clientId);
            _interface->consoleAppendTextClient(_clientId, "J'attends que mes cheveux repoussent");
            _salon->waitingForHairToGrow(_clientId);
        }
        _interface->consoleAppendTextClient(_clientId, "Le salon est fermé... Zut !");
        _salon->goHome(_clientId);
    }

    \end{lstlisting}

    \begin{itemize}
        \item \textbf{Attempting Salon Access}: Each client checks if there is available space in the salon. If the salon is full, the client will walk around and retry after some time.
        \item \textbf{Receiving Haircut}: Once access to the salon is granted, the client either goes to the barber's chair for a haircut, or goes to a waiting chair. This involves waiting for the barber to complete the haircut, and the management of a ticketing system to keep the right order.
        \item \textbf{Post-Haircut}: After the haircut, the client simulates waiting for hair to grow before potentially attempting another visit.
    \end{itemize}

    The client's cycle continues as long as the salon is in service. Once the salon closes, the last clients in the salon wait for the barber to finish the cut, then the clients go home.

    \subsection{Guarantee the client order}

    In the initial stages of designing the barbershop simulation, a queue data structure was considered to manage the order in which clients would be served, adhering to the FIFO principle. However, we realized that the waiting process in the Mesa monitor essentially forms a "virtual queue," where clients wait for their turn based on the condition variables. This insight led to the adoption of a simpler ticketing system.

    The ticketing system works by assigning a unique ticket number to each client as they attempt to access the salon. This ticket number determines the client's position in the service order. Clients check if their ticket number matches the next number to be served (\texttt{\_nextTicket}). If not, they wait in the \texttt{accessSalon} method, effectively queuing in a virtual waiting line. Once the barber completes a haircut, the \texttt{\_nextTicket} number is incremented, and the corresponding client is notified to proceed for their service. This method ensures that clients are served in the exact order of their arrival, maintaining the FIFO. This ticketing approach takes advantage of the existing synchronization of the Mesa monitor without the need for an explicit queue data structure.

    \pagebreak

    \subsection{Mesa monitor implementation}

    The Mesa monitor paradigm is characterized by the use of condition variables along with a mutex to safely access and modify shared state. A mutual exclusion lock ensures atomic access to the shared state of the salon, such as the number of clients inside, the status of the barber chair, and the ticketing system.

    Several condition variables are used to manage different synchronization aspects:
    \begin{itemize}
        \item \texttt{\_barber}: Signaled when a client needs to wake up the sleeping barber.
        \item \texttt{\_client}: Notified when it's time for the next client to proceed for their haircut.
        \item \texttt{\_clientOnWorkingChair}: Used to synchronize the client's movement to the barber chair.
        \item \texttt{\_beautifyDone}: Signaled when the barber completes a haircut.
        \item \texttt{\_clientEnteringSalon}: Used for rare cases when the barber is awake, and a client is entering the salon.
    \end{itemize}

    Clients check if the salon is full. If full, they leave and retry later. If the salon is not full, clients either wake up the sleeping barber then proceed directly to the barber chair, or take a ticket and wait. Clients wait for the barber to complete the haircut of the current client, signaled by \texttt{\_beautifyDone}. Post-haircut, clients release the barber chair and wait for hair to grow.

    The barber goes to sleep if no clients are present, waiting on the \texttt{\_barber} condition variable. The barber picks the next client and waits for them to be ready on the working chair. Once the client is ready, the barber performs the haircut, signaling \texttt{\_beautifyDone} upon completion.

    \section{Automated Testing of Barber and Clients Sequences}

    To ensure the correctness of the simulation, we implemented automated tests targeting the behavioral sequences of both the barber and the clients. These tests are crucial for verifying that the sequences adhere to predefined, valid patterns that reflect the intended logic of our program.

    \subsection{Defining Valid Sequences}

    Our testing strategy involves defining "valid sequences" for both the barber and the clients. These sequences are essentially templates of actions that the barber and clients are expected to perform in a specific order under normal operating conditions.

    These valid sequences are defined as arrays of enums, representing distinct actions. By using enums, we provide a readable representation of each action in the sequences.

    \subsection{Recording Sequences During Execution}

    As the simulation runs, each action taken by the barber or a client is recorded into a vector. This is accomplished by placing "push back" operations within the PcoSalon class's methods, which capture the sequence of actions as they occur in real-time. These vectors serve as the actual sequences to be tested against our predefined valid sequences at the end of the simulation.

    \subsection{Analyzing and Validating the Sequences}

    Once the simulation ends, the testing phase begins. Here, we analyze the recorded sequences to ensure they align with our predefined valid sequences. The analysis involves segmenting the sequences and then systematically comparing each segment against the valid sequences.

    For the barber, whose sequences can vary based on situational factors (such as whether the barber was asleep or awake at the start of the sequence), the segmentation is based on the consistent ending action in each cycle. For clients, whose actions form repeatable loops, the segmentation is based on the start of each loop.

    If a recorded sequence matches any of the valid sequences, it is deemed correct. If not, the sequence is flagged as incorrect, indicating a potential issue in the simulation logic or sequence implementation.


    \section{Manual tests}

    Because the automated tests can only verify the operating cycle of the barber and clients, we also have to do manual testing.

    Synchronization tests :
    \begin{itemize}
        \item Plus de clients(8) que de sièges(2)
        \item Plus de sièges(8) que de clients(2)
        \item Le même nombre de clients que de sièges(4)
        \item Pas de siege et un seul client
        \item Pas de siege et plusieurs clients (8)
        \item Pas de siege et pas de client
        \item Plusieurs sièges(4) et un seul client
        \item Un seul siège et plusieurs clients(20)
        \item Beaucoup de clients (30) et de sièges(20)
    \end{itemize}

    Program end tests :
    \begin{itemize}
        \item Un client entre dans le salon
        \item Un client va s'asseoir
        \item Un client se fait couper les cheveux
        \item Un client se fait couper les cheveux et personne n'attend
        \item Un client attend que ses cheveux poussent
        \item Un client fait un tour
        \item Le barbier dort
        \item Le barbier se réveille
    \end{itemize}

    Client entrance order tests :
    \begin{itemize}
        \item Lorqu'il y a un seul client
        \item Lorsqu'il y a plusieurs clients(8)
    \end{itemize}

    Hair cut order test:
    \begin{itemize}
        \item Lorsqu'il y a plusieurs clients(20) et sièges (10)
    \end{itemize}

    Other tests :
    \begin{itemize}
        \item Les clients ne font un tour que s'il n'y a plus de place dans le salon
        \item Les clients ne rentrent chez eux que si le salon est fermé
        \item Le barbier va se coucher quand il n'y a pas de clients
        \item Lorsque le barbier dort et qu'un client est entré dans le salon, il le réveille
        \item Le barbier s'arrête quand il n'y a plus de clients et que la journée est terminée
    \end{itemize}

    \subsection{Edge case}
    We discovered an edge case that we had to test for. Most of the time, when the simulation begins, the barber goes to sleep as there are no client in the salon yet. However, in rare scenarios, the barber is awake when the first client comes into the salon. In this case, we had to make the barber wait until the client is fully inside the salon (wait that the animation is finished) before picking the next client, otherwise, the barber would pick the nex ticket, while no client have already taken a ticket, leading to a deadlock. To test for this case, we simply added a sleep(1) before the main while loop in the barber::run method.
    Note that when this edge case arrise, we have chosen to put the first client directly on the barber chair, as we found that making the client in the waiting chair useless. In addition, this choice allows an other client to enter the salon.

    \section{Conclusion}

    \section*{Appendix}

    \section{Appendix name}


\end{document}
